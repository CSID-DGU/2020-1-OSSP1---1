num,answer_text,question_text
1,"C++에서는 변수, 함수, 구조체, 클래스 등을 서로 구분하기 위해서 이름으로 사용되는 다양한 내부 식별자(identifier)를 가지고 있다. 하지만 프로그램이 복잡해지고 여러 라이브러리가 포함될수록 내부 식별자 간에 충돌할 가능성도 그만큼 커진다. 이러한 이름 충돌 문제를 C++에서는 네임스페이스(namespace)를 통해 해결하고 있다.","네임스페이스? "
2,"C++ 표준 라이브러리 (C++ Standard Library)는 C++과 C++ ISO 표준 자체로 쓰여진 클래스들과 함수들의 집합이다. C++ 표준 라이브러리는 여러 제네릭 컨테이너들, 그리고 이러한 컨테이너들과 함수 객체, 제네릭 문자열, 스트림(인터렉티브와 파일 입출력을 포함하는), 몇몇 언어 특징 그리고 숫자의 제곱근을 찾는 것 같은 작업을 위한 모든 함수들을 활용하기 위한 함수들을 제공한다.","표준라이브러리? "
3,"Namespace를 선언된 위치로 모두 끌고 오는 명령이다. 사용 방법은 using std; 처럼 namespace를 지칭하면 된다.","네임스페이스 using이 무엇인가요?"
NULL,"첫째, 네임스페이스 using을 헤더 파일에 넣지 않는다.둘째, using 다이렉티브를 헤더 파일에 넣지 않는다.셋째, #include 전에 using 을 쓰지 말자.","네임스페이스를 쓸 때 하지 말아야 할 행동이 있나요?"
NULL,"헤더에는 컴파일 해야하는 헤더 만 포함해야 한다. 이를 시행하는 쉬운 방법은 다른 헤더보다 먼저 각 소스 파일의 고유 헤더를 첫 번째로 포함하는 것이다. 그러면 헤더가 자체 포함되어 있지 않으면 소스 파일이 컴파일되지 않는다. 예를 들어, 라이브러리 내에서 구현 세부 사항 클래스를 참조하는 경우에는 #include이러한 선언 된 클래스의 정의를 완전히 제어 할 수 있기 때문에 대신 전달 선언을 사용할 수 있다 .","C ++ 헤더에서 네임 스페이스 사용하면 안되는 이유는 무엇인가요?"
NULL,"알고리즘, 컨테이너, 기능, 반복자로 이루어져 있다.","표준라이브러리의 구성 요소는 무엇인가요?"
NULL,"예, C ++는 원래 C 라이브러리를 C ++에서 쉽게 사용할 수 있도록 설계되었습니다. ","C 표준 라이브러리의 함수를 C ++에서 사용할 수 있습니까?"
NULL,"가능합니다.그것은 C ++, FORTRAN, 어셈블러 또는 그 문제에 대한 대부분의 다른 언어로 작성된 라이브러리에서 C API를 내보내는 것과 매우 비슷합니다.","C ++에서 C 표준 라이브러리 구현하는 것은 가능한가요?"
NULL,"객체 공통의 속성이나 기능을 묶어 특성을 일반화하고 세부사항을 제거하여 단순하게 만드는 것이다. 객체 지향적 관점에서 클래스를 정의하는 것을 뜻한다.","추상화? "
NULL,"기존에 만들었던 객체와 클래스 등을 상속과 오버로딩(Overloading), 오버라이딩(Overriding) 등을 통해 쉽게 다시 사용하는 것을 뜻한다.","재사용? "
NULL,"캡슐화에는 일반 또는 특수 동작에 대한 구현 세부 정보가 숨겨져 있습니다. 추상화는 일반화 (예 : 일련의 동작)를 제공합니다.","추상화와 캡슐화의 차이점은 무엇입니까?"
NULL,"추상화는 구현을 숨기는 기술입니다. 핵심은 그 대답에 그다지 많지 않습니다. 추상화에 대한 의미의 대부분은 그것이 사용되는 방법과 이유에서 비롯됩니다.","추상화란 무엇입니까?"
NULL,"추상화는 복잡성을 제어하는 ​​데 사용됩니다.","추상화를 사용하는 이유?"
NULL,"코드를 반복해서 쓰지 않고, 한번 쓴 함수를 호출해서 재사용할 수 있다.","재사용성에 함수가 중요한 이유?"
NULL,"클래스와 상속개념이 있습니다.","코드를 재사용하기 위한 방법에는 무엇이 있나요?"
NULL,"상속(inheritance)은 추상화, 캡슐화와 더불어 객체 지향 프로그래밍을 구성하는 중요한 특징 중 하나이다.상속은 사용자에게 높은 수준의 코드 재활용성을 제공하며, 클래스 간의 계층적 관계를 구성함으로써 다형성의 문법적 토대를 마련한다","상속이 무엇인가요?"
NULL,"C++ 클래스의 객체 생성 방법에는 다음과 같은 2가지 방법이 있다.","객체의 생성과 활용? "
NULL,"클래스는 객체를 만들어 내기 위해 정의된 설계도로 클래스는 객체가 아니고, 실체도 아니다. 멤버 변수와 멤버 함수로 구성되며, 선언은 class키워드를 이용하여 선언한다. ","클래스란? "
NULL,"외부의 잘못된 사용으로 인해 객체가 손상되지 않도록 하기 위해 접근제한자 (public, private)를 사용하여 설정한다.","객체를 캡슐화 하는 목적은 무엇인가요?"
NULL,"객체를 생성과 동시에 초기화해주기 위해 필요하다","생성자가 필요한 이유는 무엇인가요?"
NULL,"소멸자는 객체가 사라질 때 필요한 마무리 작업을 하기 위해 필요합니다. 즉, 동적으로 할당 받은 메모리를 돌려주는 등의 일을 할 때 필요합니다.","소멸자가 필요한 이유는 무엇인가요?"
NULL,"클래스의 재사용을 위해서이다. 클래스를 사용하고자 하는 다른 c++파일에서는 컴파일 시 클래스의 선언부만 필요하기 때문이다.","클래스 선언과 구현의 분리는 왜 해야 하나요?"
NULL,"C++구조체와 클래스는 기능적으로 동일합니다. 디민 오직 한가지 다른 점은, 클래스의 디폴트 접근 지정이 private인 반면, 구조체는 public입니다.","구조체와 클래스의 차이점은 무엇인가요?"
NULL,"정답은 없습니다. 개발자에 따라 멤버 변수만 있는 자료구조의 경우 구조체를 사용하기도 합니다.","구조체가 클래스와 거의 같다면 무엇을 쓰는 게 좋은 가요?"
NULL,"C++에서는 객체를 다루기 위해 객체에 대한 포인터 변수를 선언하고, 객체의 주소를 저장할 수 있다. 언제든 객체가 저장된 주소만 알고 있다면, 그 주소를 이용해 객체 안의 변수 값을 읽고 쓰고 멤버 함수를 호출할 수 있다.",객체포인터?
NULL,"같은 클래스형의 객체가 여러 개 필요하다면 배열로 선언할 수 있다.",객체배열?
NULL,"할당은 정적할당과 동적할당으로 나뉜다. 정적할당은 변수 선언을 통해 필요한 메모리 할당을 하는 것이고, 동적 할당은 필요한 양이 예측되지 않는 경우, 실행 중에 운영체제로부터 할당 받는 경우 이루어진다. 동적 메모리할당은 malloc(), free() 라이브러리 함수를 사용한다. new연산자를 통해 객체의 동적생성을 할 수 있고 이때 생성자를 호출한다. Delete 연산자를 통해 객체의 동적 소멸을 할 수 있고, 소멸자 호출 뒤 객체를 heap에 반환한다.","동적메모리와 객체? "
NULL,"초기화 되지 않은 객체 포인터를 사용하면 오류가 발생할 수 있다.","객체 포인터 사용시 주의할 점은 무엇인가요?"
NULL,"포인터p를 사용하여 객체처럼 접근하는 방법, 배열의 이름을 포인터로 사용하는 방법, 포인터 p의 정수연산을 이용하는 방법이 있다.","객체 포인터를 사용하여 객체 배열을 다루는 방법은 무엇이 있나요?"
NULL,"배열은 변수 선언과 함께 자신의 데이터를 저장할 공간을 배열의 크기만큼 연속적인 공간을 가진다. 포인터는 자신이 데이터를 저장할 공간을 가지지 않고 저장할 공간이 있는 위치를 저장하는 메모리 번지를 저장한다.","배열과 포인터의 차이점은 무엇인가요?"
NULL,"기본 생성자가 없는 경우에 발생할 수 있다. ","객체 배열 선언문에서 컴파일 오류가 발생하는 이유는 무엇일까요?"
NULL,"객체 배열 선언문은 오직 매개변수 없는 기본 생성자를 호출한다.","객체 배열과 생성자의 관계는 무엇인가요?"
NULL,"그렇다. 함수가 종료하면 함수내에 선언된 배열도 소멸된다. 배열이 소멸 되면, 모든 원소 객체가 소멸 되며 각 원소 객체마다 소멸자가 호출된다.","함수가 종료하면 배열도 소멸하나요?"
NULL,"힙 메모리가 부족하면 new는 null을 리턴 하므로, new의 리턴 값이 null인지 검사하는 것이 좋다.","메모리 할당 전 주의할 상황은 무엇인가요?"
NULL,"Delete로 메모리를 반환할 때 적절하지 못한 포인터를 사용하면 실행오류가 발생합니다.","Delete사용시 주의할 사항은 무엇인가요?"
NULL,"사용할 수 있지만, malloc과 free를 사용하기 위해서는 <cstdlib>를 include해야 하고, new delete는 어떤 헤더파일도 include할 필요가 없으므로 후자를 사용하는 것이 좋다.","C언어의 malloc과free를 c++에서도 사용할 수 있나요?"
NULL," 함수는 호출할 시 객체의 주소만 전달한다. 따라서 생성자와 소멸자가 실행되지 않는 구조이다. 함수의 매개변수는 개체에 대한 포인터 변수로 선언한다. ","함수와 참조? "
NULL,"객체의 복사 생성시 호출되는 특별한 생성자이다. 한 클래스에 오직 한 개만 선언 가능하고 보통 생성자와 클래스 내에 중복 선언이 가능하다.","복사생성자? "
NULL,"this는 자기 자신을 가리키고 있는 포인터 개념이고","C++ this 포인터와 *this의 차이?"
NULL,"초기화가 없다면 컴파일 오류가 발생한다. 참조 변수의 배열을 만들 수 없다. ","참조 변수 선언 시 주의사항은 무엇인가요?"
NULL,"C++컴파일러는 매개변수 객체의 생성자는 실행되지 않고 소멸자만 실행되도록 하는 것이 문제가 될 수 있습니다.","값에 의한 호출로 객체를 전달할 시에 문제점은 무엇인가요?"
NULL,"얕은 복사 생성자를 이용하면 포인터가 가진 메모를 원본과 사본 객체가 공유하는 문제가 생기고, 프로그램이 비정상 종료되기도 하므로 깊은 복사 생성자를 사용하는 것이 좋다.","클래스에 포인터 변수가 있는 경우. 어떤 복사 생성자를 사용하는 것이 좋나요?"
NULL,"복사 생성은 객체를 생성할 때, 원복 객체를 복사하여 생성하는 것을 말합니다.","복사 생성이 무엇인가요?"
NULL,"컴파일러가 디폴트 복사 생성자를 자동 삽입하며, 디폴트 복사 생성자는 얕은 복사를 실행합니다.","복사 생성자를 생성하지 않으면 어떻게 되나요?"
NULL,"이름이 동일하고, 매개변수타입 변수 개수가 달라야 하며, 리턴 타입은 함수 중복에 고려되지 않는다는 조건이 있다.","중복함수의 조건은 무엇인가요?"
NULL,"작성이 편리하고, 이름을 구분 지어 기억할 필요가 없어 함수를 잘못 호출하는 실수를 줄일 수 있다.","함수중복은 어떤 편리함을 주나요?"
NULL,"함수 중복은 컴파일 시에 이루어지기 때문에, 함수 중복으로 인한 실행 시간 저하는 없다.","함수 중복은 실행시간을 저하시키나요?"
NULL,"전역 변수나 전역 함수를 클래스에 캡슐화 할 때, 객체 사이에 공유 변수를 만들고자 할 때 사용된다.","STATIC이 활용되는 목적?"
NULL,"STATIC멤버 함수는 this를 사용할 수 없다.","STATIC멤버 함수 사용시 주의점?"
NULL,"객체의 멤버로 접근하거나, 클래스명과 범위지정 연산자로 접근할 수 있다. ","Static멤버는 어떻게 사용할 수 있나요?"
NULL," 프로그램이 시작될 때 생성 되어 프로그램 종료시 소멸되는 클래스의 멤버로, 클래스 당 하나만 생성, 클래스 멤버라고 불린다. 클래스의 모든 객체들이 공유하는 멤버다. Non-static 멤버: 객체가 생성될 때 함께 생성되고, 객체마다 별도로 생성되므로 인스턴스 멤버라고 불린다.","Static 멤버? "
NULL,"동일한 이름의 함수가 공존 가능하다는 C언어에서는 불가능한 C++의 특징이다. Function overloading이라고도 불리며 보통 함수들 사이와 클래스의 멤버 함수들 사이, 상속 관계에 있는 기본 클래스와 파생 클래스의 멤버 함수들 사이에서 중복이 가능하다. 중복된 함수들은 이름이 동일해야 하고 매개 변수 타입이 다르거나 개수가 달라야 한다. 리턴 타입은 함수 중복과는 무관하다.","함수중복? "
NULL,"프렌드 함수는 클래스의 멤버 함수가 아닌 외부 함수, 즉 전역함수나 다른 클래스의 멤버함수를 뜻한다. 클래스의 모든 멤버를 접근할 수 있는 권한이 부여된다. 클래스의 멤버로 선언하기에는 무리가 있고, 클래스의 모든 멤버를 자유롭게 접근 할 수 있는 일부 외부 함수 작성 시 필요하다.",프렌드?
NULL,"C++언어에 본래 있는 연산자를 중복 사용하여 피 연산자 타입이 다른 새로운 연산자를 정의하는 것을 뜻한다. 연산자는 함수 형태로 구현되며 반드시 클래스와 관계를 가진다. 피연산자의 개수를 바꿀 수 없고 연산의 우선 순위가 변경되지 않는다.","연산자 중복? "
NULL,"클래스의 private, protected멤버를 접근해야 하는 특별한 경우, 이 함수를 외부 함수로 작성하고 프렌드로 선언한다.","프렌드 함수는 왜 필요할까?"
NULL,"클래스 외부에 작성된 함수,다른 클래스의 멤버 함수, 다른 클래스의 모든 멤버 함수를 프렌드로 선언할 수 있다.","프렌드 함수를 선언할 수 있는 경우는 무엇인가요?"
NULL,"프렌드 선언은 private, public 영역 등 아무 위치에나 가능하다.","프렌드를 선언하는 위치는 어디인가요?"
NULL,"(. .* :: ?)는 중복이 불가능하다.","모든 연산자는 중복가능한가요?"
NULL,"하나의 연산자 함수를 멤버 함수와 프렌드 함수로 동시에 구현할 수 없다.","동일한 연산자 함수를 멤버 함수와 프렌드 함수로 동시 구현할 수 있나요?"
NULL,"연산자 함수는 디폴트 매개변수를 가질 수 없다.","연산자 함수에 디폴트 매개변수를 사용할 수 있나요?"
