num,question_text,answer_text
1,네임스페이스? ,"C++에서는 변수, 함수, 구조체, 클래스 등을 서로 구분하기 위해서 이름으로 사용되는?다양한 내부 식별자(identifier)를?가지고 있다. 하지만 프로그램이 복잡해지고?여러 라이브러리가 포함될수록 내부 식별자 간에?충돌할 가능성도 그만큼 커진다. 이러한 이름?충돌 문제를 C++에서는 네임스페이스(namespace)를 통해 해결하고 있다."
2,표준라이브러리? ,"C++ 표준 라이브러리 (C++ Standard Library)는 C++과 C++ ISO 표준 자체로 쓰여진 클래스들과 함수들의 집합이다. C++ 표준 라이브러리는 여러 제네릭 컨테이너들, 그리고 이러한 컨테이너들과 함수 객체, 제네릭 문자열, 스트림(인터렉티브와 파일 입출력을 포함하는), 몇몇 언어 특징 그리고 숫자의 제곱근을 찾는 것 같은 작업을 위한 모든 함수들을 활용하기 위한 함수들을 제공한다."
3,네임스페이스 using이 무엇인가요?,Namespace를 선언된 위치로 모두 끌고 오는 명령이다. 사용 방법은 using std; 처럼 namespace를 지칭하면 된다.
4,네임스페이스를 쓸 때 하지 말아야 할 행동이 있나요?,"첫째, 네임스페이스 using을 헤더 파일에 넣지 않는다.둘째, using 다이렉티브를 헤더 파일에 넣지 않는다.셋째, #include 전에 using 을 쓰지 말자."
5,C ++ 헤더에서 네임 스페이스 사용하면 안되는 이유는 무엇인가요?,"헤더에는 컴파일 해야하는 헤더 만 포함해야 한다.?이를 시행하는 쉬운 방법은 다른 헤더보다 먼저 각 소스 파일의 고유 헤더를 첫 번째로 포함하는 것이다.?그러면 헤더가 자체 포함되어 있지 않으면 소스 파일이 컴파일되지 않는다.?예를 들어, 라이브러리 내에서 구현 세부 사항 클래스를 참조하는 경우에는?#include이러한 선언 된 클래스의 정의를 완전히 제어 할 수 있기 때문에?대신 전달 선언을 사용할 수 있다?."
6,표준라이브러리의 구성 요소는 무엇인가요?,"알고리즘, 컨테이너, 기능, 반복자로 이루어져 있다."
7,C 표준 라이브러리의 함수를 C ++에서 사용할 수 있습니까?,"예, C ++는 원래 C 라이브러리를 C ++에서 쉽게 사용할 수 있도록 설계되었습니다.?"
8,C ++에서 C 표준 라이브러리 구현하는 것은 가능한가요?,"가능합니다.그것은 C ++, FORTRAN, 어셈블러 또는 그 문제에 대한 대부분의 다른 언어로 작성된 라이브러리에서 C API를 내보내는 것과 매우 비슷합니다."
9,추상화? ,객체 공통의 속성이나 기능을 묶어 특성을 일반화하고 세부사항을 제거하여 단순하게 만드는 것이다. 객체 지향적 관점에서 클래스를 정의하는 것을 뜻한다.
10,재사용? ,"기존에 만들었던 객체와 클래스 등을 상속과 오버로딩(Overloading), 오버라이딩(Overriding) 등을 통해 쉽게 다시 사용하는 것을 뜻한다."
11,추상화와 캡슐화의 차이점은 무엇입니까?,캡슐화에는 일반 또는 특수 동작에 대한 구현 세부 정보가 숨겨져 있습니다. 추상화는 일반화 (예 : 일련의 동작)를 제공합니다.
12,추상화란 무엇입니까?,추상화는 구현을 숨기는 기술입니다.?핵심은 그 대답에 그다지 많지 않습니다.?추상화에 대한 의미의 대부분은 그것이 사용되는 방법과 이유에서 비롯됩니다.
13,추상화를 사용하는 이유?,추상화는 복잡성을 제어하는 ??데 사용됩니다.
14,재사용성에 함수가 중요한 이유?,"코드를 반복해서 쓰지 않고, 한번 쓴 함수를 호출해서 재사용할 수 있다."
15,코드를 재사용하기 위한 방법에는 무엇이 있나요?,클래스와 상속개념이 있습니다.
16,상속이 무엇인가요?,"상속(inheritance)은 추상화, 캡슐화와 더불어 객체 지향 프로그래밍을 구성하는 중요한 특징 중 하나이다.상속은 사용자에게 높은 수준의 코드 재활용성을 제공하며, 클래스 간의 계층적 관계를 구성함으로써?다형성의 문법적 토대를 마련한다"
17,객체의 생성과 활용? ,C++ 클래스의 객체 생성 방법에는 다음과 같은 2가지 방법이 있다.
18,클래스란? ,"클래스는 객체를 만들어 내기 위해 정의된 설계도로 클래스는 객체가 아니고, 실체도 아니다. 멤버 변수와 멤버 함수로 구성되며, 선언은 class키워드를 이용하여 선언한다. "
19,객체를 캡슐화 하는 목적은 무엇인가요?,"외부의 잘못된 사용으로 인해 객체가 손상되지 않도록 하기 위해 접근제한자 (public, private)를 사용하여 설정한다."
20,생성자가 필요한 이유는 무엇인가요?,객체를 생성과 동시에 초기화해주기 위해 필요하다
21,소멸자가 필요한 이유는 무엇인가요?,"소멸자는 객체가 사라질 때 필요한 마무리 작업을 하기 위해 필요합니다. 즉, 동적으로 할당 받은 메모리를 돌려주는 등의 일을 할 때 필요합니다."
22,클래스 선언과 구현의 분리는 왜 해야 하나요?,클래스의 재사용을 위해서이다. 클래스를 사용하고자 하는 다른 c++파일에서는 컴파일 시 클래스의 선언부만 필요하기 때문이다.
23,구조체와 클래스의 차이점은 무엇인가요?,"C++구조체와 클래스는 기능적으로 동일합니다. 디민 오직 한가지 다른 점은, 클래스의 디폴트 접근 지정이 private인 반면, 구조체는 public입니다."
24,구조체가 클래스와 거의 같다면 무엇을 쓰는 게 좋은 가요?,정답은 없습니다. 개발자에 따라 멤버 변수만 있는 자료구조의 경우 구조체를 사용하기도 합니다.
25,객체포인터?,"C++에서는 객체를 다루기 위해 객체에 대한?포인터 변수를 선언하고,?객체의 주소를 저장할 수 있다. 언제든 객체가 저장된 주소만 알고 있다면, 그 주소를 이용해 객체 안의 변수 값을 읽고 쓰고 멤버 함수를 호출할 수 있다."
26,객체배열?,같은 클래스형의 객체가 여러 개 필요하다면 배열로 선언할 수 있다.
27,동적메모리와 객체? ,"할당은 정적할당과 동적할당으로 나뉜다. 정적할당은 변수 선언을 통해 필요한 메모리 할당을 하는 것이고, 동적 할당은 필요한 양이 예측되지 않는 경우, 실행 중에 운영체제로부터 할당 받는 경우 이루어진다. 동적 메모리할당은 malloc(), free() 라이브러리 함수를 사용한다. new연산자를 통해 객체의 동적생성을 할 수 있고 이때 생성자를 호출한다. Delete 연산자를 통해 객체의 동적 소멸을 할 수 있고, 소멸자 호출 뒤 객체를 heap에 반환한다."
28,객체 포인터 사용시 주의할 점은 무엇인가요?,초기화 되지 않은 객체 포인터를 사용하면 오류가 발생할 수 있다.
29,객체 포인터를 사용하여 객체 배열을 다루는 방법은 무엇이 있나요?,"포인터p를 사용하여 객체처럼 접근하는 방법, 배열의 이름을 포인터로 사용하는 방법, 포인터 p의 정수연산을 이용하는 방법이 있다."
30,배열과 포인터의 차이점은 무엇인가요?,배열은 변수 선언과 함께 자신의?데이터를 저장할 공간을?배열의?크기만큼 연속적인 공간을 가진다.?포인터는 자신이 데이터를 저장할 공간을 가지지 않고 저장할 공간이 있는 위치를 저장하는 메모리 번지를 저장한다.
31,객체 배열 선언문에서 컴파일 오류가 발생하는 이유는 무엇일까요?,기본 생성자가 없는 경우에 발생할 수 있다. 
32,객체 배열과 생성자의 관계는 무엇인가요?,객체 배열 선언문은 오직 매개변수 없는 기본 생성자를 호출한다.
33,함수가 종료하면 배열도 소멸하나요?,"그렇다. 함수가 종료하면 함수내에 선언된 배열도 소멸된다. 배열이 소멸 되면, 모든 원소 객체가 소멸 되며 각 원소 객체마다 소멸자가 호출된다."
34,메모리 할당 전 주의할 상황은 무엇인가요?,"힙 메모리가 부족하면 new는 null을 리턴 하므로, new의 리턴 값이 null인지 검사하는 것이 좋다."
35,Delete사용시 주의할 사항은 무엇인가요?,Delete로 메모리를 반환할 때 적절하지 못한 포인터를 사용하면 실행오류가 발생합니다.
36,C언어의 malloc과free를 c++에서도 사용할 수 있나요?,"사용할 수 있지만, malloc과 free를 사용하기 위해서는 <cstdlib>를 include해야 하고, new delete는 어떤 헤더파일도 include할 필요가 없으므로 후자를 사용하는 것이 좋다."
37,함수와 참조? , 함수는 호출할 시 객체의 주소만 전달한다. 따라서 생성자와 소멸자가 실행되지 않는 구조이다. 함수의 매개변수는 개체에 대한 포인터 변수로 선언한다. 
38,복사생성자? ,객체의 복사 생성시 호출되는 특별한 생성자이다. 한 클래스에 오직 한 개만 선언 가능하고 보통 생성자와 클래스 내에 중복 선언이 가능하다.
39,C++ this 포인터와 *this의 차이?,this는 자기 자신을 가리키고 있는 포인터 개념이고
40,참조 변수 선언 시 주의사항은 무엇인가요?,초기화가 없다면 컴파일 오류가 발생한다. 참조 변수의 배열을 만들 수 없다. 
41,값에 의한 호출로 객체를 전달할 시에 문제점은 무엇인가요?,C++컴파일러는 매개변수 객체의 생성자는 실행되지 않고 소멸자만 실행되도록 하는 것이 문제가 될 수 있습니다.
42,클래스에 포인터 변수가 있는 경우. 어떤 복사 생성자를 사용하는 것이 좋나요?,"얕은 복사 생성자를 이용하면 포인터가 가진 메모를 원본과 사본 객체가 공유하는 문제가 생기고, 프로그램이 비정상 종료되기도 하므로 깊은 복사 생성자를 사용하는 것이 좋다."
43,복사 생성이 무엇인가요?,"복사 생성은 객체를 생성할 때, 원복 객체를 복사하여 생성하는 것을 말합니다."
44,복사 생성자를 생성하지 않으면 어떻게 되나요?,"컴파일러가 디폴트 복사 생성자를 자동 삽입하며, 디폴트 복사 생성자는 얕은 복사를 실행합니다."
45,중복함수의 조건은 무엇인가요?,"이름이 동일하고, 매개변수타입 변수 개수가 달라야 하며, 리턴 타입은 함수 중복에 고려되지 않는다는 조건이 있다."
46,함수중복은 어떤 편리함을 주나요?,"작성이 편리하고, 이름을 구분 지어 기억할 필요가 없어 함수를 잘못 호출하는 실수를 줄일 수 있다."
47,함수 중복은 실행시간을 저하시키나요?,"함수 중복은 컴파일 시에 이루어지기 때문에, 함수 중복으로 인한 실행 시간 저하는 없다."
48,STATIC이 활용되는 목적?,"전역 변수나 전역 함수를 클래스에 캡슐화 할 때, 객체 사이에 공유 변수를 만들고자 할 때 사용된다."
49,STATIC멤버 함수 사용시 주의점?,STATIC멤버 함수는 this를 사용할 수 없다.
50,Static멤버는 어떻게 사용할 수 있나요?,"객체의 멤버로 접근하거나, 클래스명과 범위지정 연산자로 접근할 수 있다. "
51,Static 멤버? ," 프로그램이 시작될 때 생성 되어 프로그램 종료시 소멸되는 클래스의 멤버로, 클래스 당 하나만 생성, 클래스 멤버라고 불린다. 클래스의 모든 객체들이 공유하는 멤버다. Non-static 멤버: 객체가 생성될 때 함께 생성되고, 객체마다 별도로 생성되므로 인스턴스 멤버라고 불린다."
52,함수중복? ,"동일한 이름의 함수가 공존 가능하다는 C언어에서는 불가능한 C++의 특징이다. Function overloading이라고도 불리며 보통 함수들 사이와 클래스의 멤버 함수들 사이, 상속 관계에 있는 기본 클래스와 파생 클래스의 멤버 함수들 사이에서 중복이 가능하다. 중복된 함수들은 이름이 동일해야 하고 매개 변수 타입이 다르거나 개수가 달라야 한다. 리턴 타입은 함수 중복과는 무관하다."
53,프렌드?,"프렌드 함수는 클래스의 멤버 함수가 아닌 외부 함수, 즉 전역함수나 다른 클래스의 멤버함수를 뜻한다. 클래스의 모든 멤버를 접근할 수 있는 권한이 부여된다. 클래스의 멤버로 선언하기에는 무리가 있고, 클래스의 모든 멤버를 자유롭게 접근 할 수 있는 일부 외부 함수 작성 시 필요하다."
54,연산자 중복? ,C++언어에 본래 있는 연산자를 중복 사용하여 피 연산자 타입이 다른 새로운 연산자를 정의하는 것을 뜻한다. 연산자는 함수 형태로 구현되며 반드시 클래스와 관계를 가진다. 피연산자의 개수를 바꿀 수 없고 연산의 우선 순위가 변경되지 않는다.
55,프렌드 함수는 왜 필요할까?,"클래스의 private, protected멤버를 접근해야 하는 특별한 경우, 이 함수를 외부 함수로 작성하고 프렌드로 선언한다."
56,프렌드 함수를 선언할 수 있는 경우는 무엇인가요?,"클래스 외부에 작성된 함수,다른 클래스의 멤버 함수, 다른 클래스의 모든 멤버 함수를 프렌드로 선언할 수 있다."
57,프렌드를 선언하는 위치는 어디인가요?,"프렌드 선언은 private, public 영역 등 아무 위치에나 가능하다."
58,모든 연산자는 중복가능한가요?,(. .* :: ?)는 중복이 불가능하다.
59,동일한 연산자 함수를 멤버 함수와 프렌드 함수로 동시 구현할 수 있나요?,하나의 연산자 함수를 멤버 함수와 프렌드 함수로 동시에 구현할 수 없다.
60,연산자 함수에 디폴트 매개변수를 사용할 수 있나요?,연산자 함수는 디폴트 매개변수를 가질 수 없다.
61,파생클래스에서는 기본클래스의 모든 함수에 접근이 가능한가요?,네.하지만 접근지정자 여부에 따라 접근가능여부가 바뀔수 있습니다. 자세한것은 접근지정과
62,다운캐스팅을 하고싶어서 코드를 작성중인데 오류가뜹니다. ,포인터로 변수가 선언이 되어있는지 확인해주세요
63,error C2248: 'Notebookcomp::Notebookcomp' : private 멤버('Notebookcomp' 클래스에서 선언),private으로 선언이 되어있는지 확인하고 public으로 바꾸어 주세요.
64,java에서는 다중상속이 불가능 한것으로 알고 있는데 C++은 다중상속이 가능한가요?,java와 다르게 C++은 다중 상속이 가능합니다
65,가상상속에 대한 이해가 잘 되지 않습니다.,가상함수->포인터의 선택에 따라 실행될 함수가 실행중에 결정되는 함수입니다.
66,상속이란?,클래스사이에서 상속 관계를 정의한다.
67,클래스상속과 객체란?,class Point{};class ColorPoint:public Point{};와 같은 형식으로 상속받게 된다.
68,상속과 객체 포인터란?,업캐스팅-파생클래스 포인터가 기본 클래스 포인터로 가리키는것
69,접근지정이란?,"private-선언된 클래스 내에서만 접근가능public-선언된 클래스나 외부 어떤 클래스, 모든 외부함수에 접근허용protected-선언된 클래스에서 접근가능,파생클래스에서만 접근허용"
70,생성자와 소멸자란?,생성자-기본클래스의 생성자가 먼저 실행된 후 파생 클래스의 생성자가 실행된다.소멸자-파생클래스의 소멸자가 먼저 실행된 후 기본 클래스의 소멸자가 나중에 실행된다.
71,다중상속란?,"class MP3{};class MobilePhone{};class MusicPhone : public MP3, public MobilePhone{};상속받고자 하는 기본클래스를 나열하여 다중 상속이 가능하다."
72,가상상속란?,파생 클래스의 선언문에서 기본 클래스 앞에 virtual로 선언한다.파생 클래스의 객체가 생성될 때 기본클래스의 멤버는 오직 한번만 생성된다.->기본클래스의 멤버가 중복하여 생성되는 것을 방지
73,상속관계에서의 함수중복 이란?,#NAME?
74,가상함수와 오버라이딩이란?,가상함수: virtual키워드로 선언된 멤버함수이다.오버라이딩: 파생클래스에서 기본 클래스의 가상함수와 동일한 이름의 함수를 선언합니다. 
75,동적바인딩이란?,오버라이딩된 함수가 무조건 호출되는것을 동적 바인딩이라고 합니다.
76,추상클래스란?,최소한 하나의 순수 가상 함수를 가진 클래스입니다.
77,일반화란?,"함수나 클래스를 일반화 시키고, 매개변수 타입을 지정하여 틀에서 찍어내듯이 함수나 클래스 코드를 생산하는 기법"
78,template이란?,함수나 클래스를 일반화하는 C++도구 template키워드로 함수나 클래스를 선언한다.
79,generic이란?,template<class T> template은 템플릿을 선언하는 키워드 class 제네릭 타입을 선언하는 키워드 T는 제네릭 타입 T를 선언하게 된다. 
80,STL이란?,표준 템플릿 라이브러리 많은 제네릭 클래스와 제네릭 함수를 포함한다.
81,vector란?,"가변 길이 배열을 구현한 제네릭 클래스 입니다.원소의 저장, 삭제, 검색 등 다양한 멤버함수를 지원한다."
82,iterator란?,반복자라 부릅니다. 컨테이너의 원소를 가리키는 포인터입니다.
83,map이란?,"#include <map>하고 ('키','값')의 쌍을 원소로 저장하는 제네릭 컨테이너 입니다. 키로 값을 검색하게 됩니다. "
84,stream이란?,"데이터의 흐름, 혹은 데이터를 전송하는 소프트웨어 모듈입니다.스트림에는 입력스트림과 출력스트림이 있습니다."
85,ostream의 멤버함수를 이용한 문자출력?,"ostream의 멤버함수 입니다. ostream& put(char ch)-ch의 문자를 스트림에 출력 ostream& write(char* str,int n)-str 배열에 있는n개의 문자를 스트림에 출력 ostream& flush()-현재 스트림 버퍼에 있는 내용 강제 출력 "
86,istream의 멤버함수를 이용한 문자입력?,"int get()-입력 스트림에서 문자를 읽어 리턴, 오류나 EOF를 만나면 -1(EOF)리턴 istream& get(char& ch)입력 스트림에서 문자를 읽어 ch에 저장, 현재 입력 스트림 객체(*this)의 참조리턴 오류나 EOF를 만나면, 스트림 내부의 오류 플래그(failbit)세팅  "
87,포맷입출력이란?,포맷입출력 방법에는 3가지가 있습니다.1.포맷 플래그2.포맷 함수 3.조작자 
88,포맷플래그란?,포맷플래그를 세팅하는 멤버함수의 종류입니다. *Long setf(Long flags) flags를 스트림의 포맷 플래그로 설정하고 이전 플래그를 리턴한다. *Long unsetf(Long flags)flags에 설정된 비트 값에 따라 스트림의 포맷 플래그를 해제하고 이진 플래그를 리턴한다.  
89,포맷함수란?,"int width(int minWidth)-출력되는 빌드의 최소 너비를 minwidth로 설정하고 이전에 설정된 너비값 리턴 char fill(char cFill)-필드와 빈칸을 cFill 문자로 채우도록 지정하고 이전 문자 값 리턴 int precision(int np)-출력되는 수의 유효숫자 자리수를 np개로 설정, 정수부분과 소수점 이하의 수의 자리를 모두 포함하고 소수점(.)은 제외   "
90,조작자란?,"manipulator, 스트림 조작자(stream manipulator) 조작자는 함수 C++ 표준 라이브러리에 구현된 조작자 : 입출력 포맷 지정 목적 개발자 만의 조작자 작성 가능 : 다양한 목적 매개 변수가 없는 조작자와 매개 변수를 가진 조작자로 구분된다. "
91,연산자란?,삽입연산자(<<)추출연산자(>>)
92,텍스트 파일?,텍스트 파일이란? 텍스트 파일은 문자를 기반으로 하는 코드 값이 저장된 파일입니다.즉 문자라는 가공조건이 하나 추가 된 형식의 파일입니다.
93,바이너리 파일?,바이너리 파일이란?우리가 많이 사용하는 .jpg .png같은 그림 파일이나 .mp3와 같은 음악파일 그리고 .exe와 같은실행파일등이 바이너리 파일에 해당합니다.
94,파일 모드?,read 모드일때 std::ifstream(파일명
95,텍스트 I/O?,#include<fstream>을 추가해야합니다. fstream file;->입출력 담당 ifstream fin;->입력 담당 ofstream fout;->출력 담당
96,바이너리 I/O?,text형태보다 더 다양한 파일을 읽고 쓸 수 있습니다. binary로 읽고 쓸때에는 옵션으로 ios::binary를 추가합니다.
97,스트링?,"(std::string) 은 문자열을 char형 벡터형태(std::vector<char>)로 나타낸 것이다. 문자열의 길이를 계산하고, 서로 다른 문자열을 연결하거나 문자열 일부를 추출하는 등의 기능을 제공한다. 문자열 관련 기능이 궁금하다면 질문해주세요"
98,오류종류?,syntax error 언어가 정의한 문법에 어긋나서 발생하는 에러 logic error logic이 틀렸을 경우 발생하는 에러 runtime error 문법도 이상없고 로직도 이상 없음. 공간이 부족하다거나 하는 경우에 발생한다.
99,예외(exception)?,예외는 프로그램의 실행 도중에 발생하는 문제 상황을 의미한다.컴파일시 발생하는 문법적인 에러는 포함이 되지 않는다.
100,코딩스타일?,"프로그래밍의 기본은 프로그래밍 언어이기에 동일한 팀내부에서는 코딩 스타일을 결정하고 관리, 유지하는것이 중요하다.코딩스타일과 주석등을 통일하여 작성하는것이 중요!!"
101,코드분할?,코드를 분할하여 사용하는 것이 가능하다. class.h class.cpp main.cpp 
102,파생클래스와 부모클래스가 같은 함수를 가지고 있는경우에는 어떻게 실행이 되나요?,함수가 중복되는 경우에는 파생클래스가 가리키는 함수를 실행하게 됩니다.
103,가상함수를 꼭 선언해야 하나요?,가상함수를 선언하는 이유는 상속받을 클래스에서 사용자가 빼먹지 않고 정의할 수 있게 하려는 의도 입니다. 코딩할 것이 많아지면 실수로 빠뜨릴 수도 있기 때문에 이런식으로 사용하게 됩니다.
104,동적바인딩과 오버라이딩은 어떤관계가 있는것이죠?,메소드 오버라이딩은 슈퍼클래스의 메소드를 무시하고 서브클래스에서 오버라이딩 된 메소드가 무조건 실행 되도록 하는 것입니다. 이런 처리를 동적바인딩이라고 하고 즉 메소드오버라이딩은 동적 바인딩을 유발하게 됩니다.
105,추상클래스와 가상함수의 차이가 궁금해요,추상클래스는 순수가상함수를 오버라이딩 하게 됩니다. 즉 상속 할때 기본클래스의 역할을 하여 파생클래스에서 구현할 함수의 형태를 보여주는 인터페이스 역할을 하는것입니다.
106,제네릭을 사용하는데 오류가 발생했어요,제네릭은 매개변수의 타입이 동일해야 합니다.매개변수의 타입이 같은지 확인해 주세요.
107,vector의 함수들에 대해 궁금해요,"vector의 함수는 다음과 같습니다. push_back(element)-벡터의 마지막에 element 추가 at(int index)-index 위치의 원소에 대한 참조 리턴 begin()-벡터의 첫 번째 원소에 대한 참조 리턴 end()-벡터의 끝(마지막 원소 다음)을 가리키는 참조 리턴 empty()-벡터가 비어 있으면 true리턴 erase(iterator it,element)-벡터에서 it가 가리키는 원소 삭제, 삭제 후 자동으로 벡터 조절 insert(iterator it,element)-벡터내 it 위치에 element 삽입 size()-벡터에 들어 있는 원소의 개수 리턴 operator[]()-지정된 원소에 대한 참조 리턴 operator=()-이 벡터를 다른 벡터에 치환(복사)"
108,map 클래스의 주요 멤버와 연산자에 대해 알려주세요,map 클래스의 주요 멤버와 연산자는 다음과 같습니다. insert(pair<> &element)-맵에 '키'와 '값'으로 구성된 pair객체 element 삽입 at(key_type&key)-맵에서 '키' 값에 해당하는 '값'리턴 begin()-맵의 첫 번째 원소에 대한 참조 리턴 end()-맵의 끝(마지막 원소 다음)을 가리키는 참조 리턴 empty()-맵이 비어 있으면 true리턴 find(key_type& key)-맵에서 '키' 값에 해당하는 원소를 가리키는 iterator 리턴 erase(iterator it)-맵에서 it가 가리키는 원소 삭제 size()-맵에 들어 있는 원소의 개수 리턴 operator[key_type& key]()-맵에서 '키' 값에 해당하는 원소를 찾아 '값'리턴 operator=()-맵 치환(복사)
109,stream의 입출력방식이 궁금해요,"c++입출력 방식에는 2가지가 있습니다. 하지만 c++표준은 스트림 방식이 지원이됩니다.다음은 stream I/O의 내용입니다. *스트림 버퍼를 이용한 입출력 방식 *입력된 키는 버퍼에 저장 *<Enter>키가 입력되면 프로그램이 버퍼에서 읽어가는 방식 *출력되는 데이터는 일차적으로 스트림 버퍼에 저장 *버퍼가 꽉 차거나, ‘\n’을 만나거나,  강제 출력 명령의 경우에만 버퍼가 출력 장치에 출력"
110,ostream을 사용한 <<연산자의 예제는 어떤식으로 작성되나요?,"ostream& operator << (ostream& stream, Point a) { stream<<(<<a.x<<"
111,파일 모드의 옵션이 궁금합니다.,ios::in-파일 입력 ios::out-파일 출력 ios::binary-이진 파일 ios::app-파일에 추가ios::trunc-파일이 존재할 경우 삭제하고 새로 생성하여 출력
112,문자열 관련 기능이 궁금합니다.,empty()-스트링이 비어있는지 확인한다. size()/length()-스트링에 들어있는 문자열의 길이를 알려준다. clear()-스트링을 빈 상태로 만든다. append()-스트링에 문자열을 추가한다. insert()-문자열을 삽입한다. erase()-주어진 길이만큼 문자들을 삭제한다. replace()-문자들을 주어진 문자열로 바꾼다. find()-문자열을 찾아 첫번째로 나타나는 문자열의 인덱스를 알려준다. compare()-주어진 문자열과 비교한다.
113,주어진 방식대로 했는데 파일이 출력이 되지 않아요.,파일의 이름이나 저장하고자 하는 파일의 경로를 한번 더 살펴봐주세요.
